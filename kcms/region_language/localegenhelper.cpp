/*
    localegenhelper.cpp
    SPDX-FileCopyrightText: 2021 Han Young <hanyoung@protonmail.com>

    SPDX-License-Identifier: GPL-2.0-or-later
*/
#include "localegenhelper.h"
#include "localegenhelperadaptor.h"

#include <QDBusConnection>
#include <QDebug>
#include <QFile>
#include <QTimer>
#include <set>

LocaleGenHelper::LocaleGenHelper()
    : m_timer(new QTimer(this))
{
    new LocaleGenHelperAdaptor(this);
    if (!QDBusConnection::systemBus().registerService(QStringLiteral("org.kde.localegenhelper"))) {
        qDebug() << "another helper is already running";
        QCoreApplication::instance()->exit();
    }
    if (!QDBusConnection::systemBus().registerObject(QStringLiteral("/LocaleGenHelper"), this)) {
        qDebug() << "unable to register service interface to dbus";
        QCoreApplication::instance()->exit();
    }
    m_authority = PolkitQt1::Authority::instance();
    connect(m_authority, &PolkitQt1::Authority::checkAuthorizationFinished, this, &LocaleGenHelper::enableLocalesPrivate);
    connect(m_timer, &QTimer::timeout, this, [] {
        QCoreApplication::instance()->exit();
    });
    m_timer->start(30 * 1000);
}

void LocaleGenHelper::enableLocales(const QStringList &locales)
{
    qDebug() << locales;
    if (m_timer->isActive()) {
        m_timer->stop();
    }
    if (m_isGenerating || !validateLocales(locales)) {
        Q_EMIT success(false);
        exitAfterTimeOut();
        return;
    }
    m_isGenerating = true;
    if (shouldGenerate()) {
        m_authority->checkAuthorization(QStringLiteral("org.kde.localegenhelper.enableLocales"),
                                        PolkitQt1::SystemBusNameSubject(message().service()),
                                        PolkitQt1::Authority::AllowUserInteraction);
    } else {
        exitAfterTimeOut();
        Q_EMIT success(true);
    }
}

void LocaleGenHelper::enableLocalesPrivate(PolkitQt1::Authority::Result result)
{
    qDebug() << result;
    if (result != PolkitQt1::Authority::Result::Yes || !editLocaleGen()) {
        Q_EMIT success(false);
        exitAfterTimeOut();
    }
}
bool LocaleGenHelper::shouldGenerate()
{
    QFile localegen(QStringLiteral("/etc/locale.gen"));
    if (!localegen.open(QIODevice::ReadOnly)) {
        return false;
    }
    m_alreadyEnabled.clear();
    while (!localegen.atEnd()) {
        QString locale = localegen.readLine().simplified();
        if (!m_comment && locale == QStringLiteral("# generated by KDE Plasma Region & Language KCM")) {
            m_comment = true;
        }
        if (locale.isEmpty() || locale.front() == QLatin1Char('#')) {
            continue;
        }
        QStringList localeAndCharset = locale.split(QLatin1Char(' '));
        if (localeAndCharset.size() != 2 || localeAndCharset.at(1) != QStringLiteral("UTF-8")) {
            continue;
        } else {
            QString localeNameWithoutCharset = localeAndCharset.front().remove(QStringLiteral(".UTF-8"));
            m_alreadyEnabled.insert(localeNameWithoutCharset);
        }
    }
    for (const auto &locale : std::as_const(m_locales)) {
        if (locale == QStringLiteral("C")) {
            continue;
        }
        if (m_alreadyEnabled.count(locale) == 0) {
            return true;
        }
    }
    return false;
}
bool LocaleGenHelper::editLocaleGen()
{
    QFile localegen(QStringLiteral("/etc/locale.gen"));
    localegen.open(QIODevice::Append);
    for (const auto &locale : std::as_const(m_locales)) {
        if (m_alreadyEnabled.count(locale) || locale == QStringLiteral("C")) {
            continue;
        } else {
            // start at newline first time
            if (!m_comment) {
                localegen.write("\n# generated by KDE Plasma Region & Language KCM\n");
                m_comment = true;
            }
            localegen.write(locale.toUtf8() + ".UTF-8 UTF-8\n");
        }
    }

    QProcess *process = new QProcess(this);
    process->setProgram(QStringLiteral("locale-gen"));
    connect(process, QOverload<int, QProcess::ExitStatus>::of(&QProcess::finished), this, &LocaleGenHelper::handleLocaleGen);
    process->start();
    return true;
}

void LocaleGenHelper::handleLocaleGen(int statusCode, QProcess::ExitStatus status)
{
    Q_UNUSED(status)
    if (statusCode == 0) {
        Q_EMIT success(true);
    } else {
        Q_EMIT success(false);
    }
    exitAfterTimeOut();
}

void LocaleGenHelper::exitAfterTimeOut()
{
    m_timer->start(30 * 1000);
}

bool LocaleGenHelper::validateLocales(const QStringList &locales)
{
    QStringList processedLocales = locales;
    for (auto &locale : processedLocales) {
        locale.remove(QStringLiteral(".UTF-8"));
        if (locale == QStringLiteral("C")) {
            continue;
        }
        auto result = m_regex.match(locale);
        if (!result.hasMatch()) {
            return false;
        }
    }
    m_locales = std::move(processedLocales);
    return true;
}
int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    new LocaleGenHelper();
    return app.exec();
}
